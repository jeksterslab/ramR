---
title: "Reticular Action Model (RAM) Notation"
author: "Ivan Jacob Agaloos Pesigan"
date: "`r Sys.Date()`"
description: >
  Learn how to get started with the basics of `ramR`.
output:
  rmarkdown::html_vignette:
    toc: true
vignette: >
  %\VignetteIndexEntry{Reticular Action Model (RAM) Notation}
  %\VignetteEngine{knitr::rmarkdown}
  %\VignetteEncoding{UTF-8}
---

```{r, include = FALSE}
knitr::opts_chunk$set(
  collapse = TRUE,
  comment = "#>"
)
```

<!-- badges: start -->
[![R build status](https://github.com/jeksterslab/ramR/workflows/R-CMD-check/badge.svg?branch=master)](https://github.com/jeksterslab/ramR/actions?workflow=R-CMD-check)
[![Travis build status](https://travis-ci.com/jeksterslab/ramR.svg?branch=master)](https://travis-ci.com/jeksterslab/ramR)
[![codecov](https://codecov.io/github/jeksterslab/ramR/branch/master/graphs/badge.svg)](https://codecov.io/github/jeksterslab/ramR) 
<!-- badges: end -->

## Description

A collection of utility functions using the Reticular Action Model (RAM) notation.

## Installation

You can install the released version of `ramR` from [GitHub](https://github.com/jeksterslab/ramR) with:

```r
remotes::install_github("jeksterslab/ramR")
```

## Symbolic Example

This is a symbolic example for the model

\begin{equation}
  y = \alpha + \beta x + \varepsilon .
\end{equation}

```{r}
A <- S <- matrix(
  data = 0,
  nrow = 3,
  ncol = 3
)
A[1, ] <- c(0, "beta", 1)
diag(S) <- c(0, "sigma[x]^2", "sigma[varepsilon]^2")
filter <- diag(2)
filter <- cbind(filter, 0)
u <- c("alpha", "mu[x]", 0)
```

The covariance expectations
can be symbolically derived using the `ramR::C_sym()` function.

```{r}
ramR::C_sym(A, S)
```

```{r, echo = FALSE, results = "asis"}
cat(
  "\\begin{equation}",
  "\\mathbf{C} =",
  Ryacas::tex(ramR::C_sym(A, S)),
  "\\end{equation}",
  sep = ""
)
```

The covariance expectations for the observed variables
can be symbolically derived using the `ramR::M_sym()` function.

```{r}
ramR::M_sym(A, S, filter)
```

```{r, echo = FALSE, results = "asis"}
cat(
  "\\begin{equation}",
  "\\mathbf{M} =",
  Ryacas::tex(ramR::M_sym(A, S, filter)),
  "\\end{equation}",
  sep = ""
)
```

The mean expectations
can be symbolically derived using the `ramR::v_sym()` function.

```{r}
ramR::v_sym(A, u)
```

```{r, echo = FALSE, results = "asis"}
cat(
  "\\begin{equation}",
  "\\mathbf{v} =",
  Ryacas::tex(ramR::v_sym(A, u)),
  "\\end{equation}",
  sep = ""
)
```

The mean expectations for the observed variables
can be symbolically derived using the `ramR::g_sym()` function.

```{r}
ramR::g_sym(A, u, filter)
```

```{r, echo = FALSE, results = "asis"}
cat(
  "\\begin{equation}",
  "\\mathbf{g} =",
  Ryacas::tex(ramR::g_sym(A, u, filter)),
  "\\end{equation}",
  sep = ""
)
```

## Numerical Example

This is a numerical example for the model

\begin{equation}
  \begin{split}
    y &= \alpha + \beta x + \varepsilon \\
    y &= 0 + 0.50 x + \varepsilon .
  \end{split}
\end{equation}


```{r}
A <- S <- matrix(
  data = 0,
  nrow = 3,
  ncol = 3
)
A[1, ] <- c(0, 1, 1)
diag(S) <- c(0, 0.25, 1)
colnames(A) <- rownames(A) <- c("y", "x", "e")
filter <- diag(2)
filter <- cbind(filter, 0)
colnames(filter) <- c("y", "x", "e")
rownames(filter) <- c("y", "x")
u <- c(0.00, 0.50, 0.00)
```

The covariance expectations
can be numerically derived using the `ramR::C_num()` function.

```{r}
ramR::C_num(A, S)
```

The covariance expectations for the observed variables
can be numerically derived using the `ramR::M_num()` function.

```{r}
ramR::M_num(A, S, filter)
```

The mean expectations
can be numerically derived using the `ramR::v_num()` function.

```{r}
ramR::v_num(A, u)
```

The mean expectations for the observed variables
can be numerically derived using the `ramR::v_num()` function.

```{r}
ramR::g_num(A, u, filter)
```

## More Information

See [GitHub Pages](https://jeksterslab.github.io/ramR/index.html)
for package documentation.
See [ramR_notes](https://jeksterslab.github.io/ramR_notes/index.html)
for notes and more examples.
