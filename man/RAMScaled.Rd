% Generated by roxygen2: do not edit by hand
% Please edit documentation in R/RAMScaled.R
\name{RAMScaled}
\alias{RAMScaled}
\alias{RAMScaled.default}
\alias{RAMScaled.yac_symbol}
\title{Scaled/Standardized RAM Matrices}
\usage{
RAMScaled(A, S, Filter, C = NULL, C.scaled = NULL, check = TRUE, ...)

\method{RAMScaled}{default}(A, S, Filter, C = NULL, C.scaled = NULL, check = TRUE, ...)

\method{RAMScaled}{yac_symbol}(
  A,
  S,
  Filter,
  C = NULL,
  C.scaled = NULL,
  check = TRUE,
  exe = TRUE,
  R = FALSE,
  format = "ysym",
  simplify = FALSE,
  ...
)
}
\arguments{
\item{A}{\verb{t by t} matrix \eqn{\mathbf{A}}.
Asymmetric paths (single-headed arrows),
such as regression coefficients and factor loadings.}

\item{S}{\verb{t by t} numeric matrix \eqn{\mathbf{S}}.
Symmetric paths (double-headed arrows),
such as variances and covariances.}

\item{Filter}{\verb{p by t} numeric matrix
\eqn{\mathbf{F}}.
Filter matrix used to select observed variables.}

\item{C}{\verb{t by t} numeric matrix \eqn{\mathbf{C}}.
Model-implied variance-covariance matrix.}

\item{C.scaled}{\verb{t by t} numeric matrix
\eqn{\mathbf{C}_{\mathrm{scaled}}}.
Scaled/standardized model-implied variance-covariance matrix.}

\item{check}{Logical.
If \code{check = TRUE} do some preprocessing
with input matrices using \code{\link[=CheckRAMMatrices]{CheckRAMMatrices()}}.}

\item{...}{...}

\item{exe}{Logical.
If \code{exe = TRUE},
executes the resulting \code{yacas} expression.
If \code{exe = FALSE},
returns the resulting \code{yacas} expression as a character string.
If \code{exe = FALSE},
the arguments \code{str}, \code{ysym}, \code{simplify}, and \code{tex}, are ignored.}

\item{R}{Logical.
If \code{R = TRUE}, returns symbolic result as an \code{R} expression.
If \code{R = FALSE}, returns symbolic result as \code{"ysym"}, \code{"str"},  or \code{"tex"}
depending of \code{format}.}

\item{format}{Character string.
Only used when \code{R = FALSE}.
If \code{format = "ysym"},
returns symbolic result as \code{yac_symbol}.
If \code{format = "str"},
returns symbolic result as a characetr string.
If \code{format = "tex"},
returns symbolic result as LaTeX math.}

\item{simplify}{Logical. Simplify symbolic results.}
}
\value{
Returns a list with the following elements

\describe{
\item{A.scaled}{
\verb{t by t} matrix \eqn{\mathbf{A}_{\mathrm{scaled}}}.
Scaled/standardized asymmetric paths (single-headed arrows),
such as regression coefficients and factor loadings.
}
\item{S.scaled}{
\verb{t by t} numeric matrix \eqn{\mathbf{S}_{\mathrm{scaled}}}.
Scaled/standardized symmetric paths (double-headed arrows),
such as variances and covariances.
}
}
}
\description{
Derives the scaled/standardized RAM matrices.
}
\details{
The scaled/standardized \eqn{\mathbf{A}} and \eqn{\mathbf{S}}
are  given by

\deqn{
  \mathbf{A}_{\mathrm{scaled}}
  =
  \mathbf{D} \mathbf{A} \mathbf{D}^{-1}
}

\deqn{
  \mathbf{S}_{\mathrm{scaled}}
  =
  \mathbf{D} \mathbf{S} \mathbf{D}
}

where \eqn{\mathbf{D}} is a diagonal matrix
whose diagonal elements are the diagonal elements of \eqn{\mathbf{C}}
raised to \eqn{-\frac{1}{2}},
that is, the inverse of the standard deviations of the variables.
}
\examples{
# Numeric -----------------------------------------------------------
# This is a numerical example for the model
# y = alpha + beta * x + e
# y = 0 + 1 * x + e
#--------------------------------------------------------------------

A <- S <- matrixR::ZeroMatrix(3)
A[1, ] <- c(0, 1, 1)
diag(S) <- c(0, 0.25, 1)
colnames(A) <- rownames(A) <- c("y", "x", "e")
Filter <- diag(2)
Filter <- cbind(Filter, 0)
colnames(Filter) <- c("y", "x", "e")
(RAM <- RAMScaled(A, S, Filter))
C(A = RAM$A.scaled, S = RAM$S.scaled)
M(A = RAM$A.scaled, S = RAM$S.scaled, Filter = Filter)
# Symbolic ----------------------------------------------------------
# This is a symbolic example for the model
# y = alpha + beta * x + e
# y = 0 + 1 * x + e
#--------------------------------------------------------------------

A <- S <- matrixR::ZeroMatrix(3)
A[1, ] <- c(0, "beta", 1)
diag(S) <- c(0, "sigmax2", "sigmae2")
(RAM <- RAMScaled(Ryacas::ysym(A), S, Filter))
RAMScaled(Ryacas::ysym(A), S, Filter, format = "str")
RAMScaled(Ryacas::ysym(A), S, Filter, format = "tex")
RAMScaled(Ryacas::ysym(A), S, Filter, R = TRUE)

C(A = RAM$A.scaled, S = RAM$S.scaled)
M(A = RAM$A.scaled, S = RAM$S.scaled, Filter = Filter)

# Assigning values to symbols

beta <- 1
sigmax2 <- 0.25
sigmae2 <- 1

RAMScaled(Ryacas::ysym(A), S, Filter)
RAMScaled(Ryacas::ysym(A), S, Filter, format = "str")
RAMScaled(Ryacas::ysym(A), S, Filter, format = "tex")
RAMScaled(Ryacas::ysym(A), S, Filter, R = TRUE)
eval(RAMScaled(Ryacas::ysym(A), S, Filter, R = TRUE))

C(A = RAM$A.scaled, S = RAM$S.scaled)
M(A = RAM$A.scaled, S = RAM$S.scaled, Filter = Filter)
}
\seealso{
Other RAM matrices functions: 
\code{\link{C}()},
\code{\link{Expectations}()},
\code{\link{E}()},
\code{\link{IminusA}()},
\code{\link{M}()},
\code{\link{S}()},
\code{\link{g}()},
\code{\link{u}()},
\code{\link{v}()}
}
\author{
Ivan Jacob Agaloos Pesigan
}
\concept{RAM matrices functions}
\keyword{ram}
